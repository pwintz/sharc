# This file was initially generated by ChatGPT. 
# https://chat.openai.com/c/6bba5889-ea07-46c6-852c-19c09db76790
import time
import numpy as np
from scipy.integrate import ode
import scarabizor
import re
import numpy

control_re = re.compile("^u:\s+(.+)$")


def convertStdOutToControlVector(stdout_str: str):
    # print("Searching for regex: " + stdout_str)
    # search_result = control_re.search(stdout_str)

    # Find the last instance of "u:"
    # u_line = stdout_str.splitlines()[-2]
    u_line = stdout_str;
    # print('u_line')
    # print(u_line)

    # Check that we have the right line.
    # if not u_line.startswith('u:'):
    #     raise ValueError('u_line did not start with "u:". Instead, it was ' + u_line)
    
    u_values = u_line.splitlines() #.strip().split("\t")
    # print("u_values: " + str(u_values))

    # Convert the list of strings to a list of floats.
    u_values = [numpy.float64(x) for x in u_values]
    # print(u_values)

    return u_values

    # if search_result:
    #     print(search_result)
    #     return search_result.group[0]
    # else: 
    #     print("NO MATCH TO REGEX FOUND")


# class PIDController:
#     def __init__(self, kp, ki, kd, setpoint):
#         self.kp = kp
#         self.ki = ki
#         self.kd = kd
#         self.setpoint = setpoint
#         self.prev_error = 0
#         self.integral = 0

#     def compute(self, current_value):
#         error = self.setpoint - current_value
#         self.integral += error
#         derivative = error - self.prev_error

#         # Calculate the control output
#         control_output = (self.kp * error) + (self.ki * self.integral) + (self.kd * derivative)

#         # Update the previous error
#         self.prev_error = error

#         return control_output

def system_derivative(t, state, control_value):
    current_position, current_velocity = state
    return [current_velocity, control_value]

if __name__ == "__main__":
    # # Define PID controller parameters
    # kp = 0.5
    # ki = 0.1
    # kd = 0.2
    # setpoint = 10.0

    # # Create a PID controller
    # pid_controller = PIDController(kp, ki, kd, setpoint)

    # Initial state of the system
    initial_state = [100.0, 0.0]

    # Create an ODE solver
    solver = ode(system_derivative).set_integrator('vode', method='bdf')
    solver.set_initial_value(initial_state, t=0)
    solver.set_f_params(0.0)

    # Time settings 
    total_time = 100
    time_step = 0.5
    # delay_scale = 1; # Stable
    delay_scale = 3000; # Unstable
    scarab = scarabizor.Scarab();

    while solver.successful() and solver.t < total_time:
        # Compute the control value once at the beginning of each time step. 
        # Insert code to call Scarab.
        # Current state value.
        x = solver.y
        # control_value = pid_controller.compute(x)
        # print('control value')
        # print(control_value)
        # print(type(control_value))
        # time_to_compute = ??
        controller_cmd_args = [str(x_i) for x_i in x]
        scarab_data = scarab.simulate('./3x3_proportional_controller', controller_cmd_args)
        
        u = convertStdOutToControlVector(scarab_data.cmd_stdout)
        delay = delay_scale*scarab_data.simulated_time_seconds

        def printSolverStatus():
            print(f't={solver.t:7.3f}, x=({solver.y[0]:5.1f}, {solver.y[1]:5.1f}), u={solver.f_params[0]:6.1f}.')

        # print(f'delay: {delay}, u: {u}')
        if delay > time_step: 
            raise ValueError('Delay is greater than time step.')
        # print(type(u))
        # Integrate the system with the control value for the entire time step
        t_control_update = solver.t + delay
        t_next_time_step = solver.t + time_step
        solver.integrate(t_control_update)
        printSolverStatus()
        solver.set_f_params(u[0])
        solver.integrate(t_next_time_step)
        printSolverStatus()

        # print(f"Time: {solver.t:.2f}, Current Position: {x[0]:.2f}")
        time.sleep(time_step)
